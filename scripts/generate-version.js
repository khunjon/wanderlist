#!/usr/bin/env node

/**
 * Version Generation Script
 * Generates version information at build time and creates environment variables
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function generateVersion() {
  const buildTime = new Date().toISOString();
  const environment = process.env.NODE_ENV || 'development';
  
  let gitHash = null;
  let version = null;
  
  try {
    // Try to get git commit hash
    gitHash = execSync('git rev-parse --short HEAD', { encoding: 'utf8' }).trim();
    version = gitHash;
    console.log(`‚úì Git hash: ${gitHash}`);
  } catch (error) {
    // Fallback to timestamp if git is not available
    console.warn('‚ö† Git not available, using timestamp for version');
    version = Date.now().toString();
  }
  
  // In production, prefer Vercel's git commit SHA if available
  if (environment === 'production' && process.env.VERCEL_GIT_COMMIT_SHA) {
    gitHash = process.env.VERCEL_GIT_COMMIT_SHA.slice(0, 8);
    version = gitHash;
    console.log(`‚úì Using Vercel git hash: ${gitHash}`);
  }
  
  const versionInfo = {
    version,
    buildTime,
    gitHash,
    environment,
  };
  
  console.log('üì¶ Generated version info:', versionInfo);
  
  return versionInfo;
}

function writeVersionFile(versionInfo) {
  const versionFilePath = path.join(process.cwd(), 'src', 'lib', 'version-info.json');
  
  try {
    // Ensure directory exists
    const dir = path.dirname(versionFilePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    // Write version info to file
    fs.writeFileSync(versionFilePath, JSON.stringify(versionInfo, null, 2));
    console.log(`‚úì Version file written to: ${versionFilePath}`);
  } catch (error) {
    console.error('‚ùå Failed to write version file:', error);
    process.exit(1);
  }
}

function updateEnvFile(versionInfo) {
  const envPath = path.join(process.cwd(), '.env.local');
  
  try {
    let envContent = '';
    
    // Read existing .env.local if it exists
    if (fs.existsSync(envPath)) {
      envContent = fs.readFileSync(envPath, 'utf8');
    }
    
    // Remove existing version variables
    envContent = envContent
      .split('\n')
      .filter(line => !line.startsWith('NEXT_PUBLIC_APP_VERSION=') && 
                     !line.startsWith('NEXT_PUBLIC_BUILD_TIME=') && 
                     !line.startsWith('NEXT_PUBLIC_GIT_HASH='))
      .join('\n');
    
    // Add new version variables
    const versionVars = [
      `NEXT_PUBLIC_APP_VERSION=${versionInfo.version}`,
      `NEXT_PUBLIC_BUILD_TIME=${versionInfo.buildTime}`,
      versionInfo.gitHash ? `NEXT_PUBLIC_GIT_HASH=${versionInfo.gitHash}` : null,
    ].filter(Boolean);
    
    // Ensure there's a newline before adding version vars
    if (envContent && !envContent.endsWith('\n')) {
      envContent += '\n';
    }
    
    envContent += '\n# Auto-generated version info\n';
    envContent += versionVars.join('\n') + '\n';
    
    fs.writeFileSync(envPath, envContent);
    console.log(`‚úì Updated .env.local with version info`);
  } catch (error) {
    console.error('‚ùå Failed to update .env.local:', error);
    // Don't exit on env file error, as it's not critical
  }
}

function createVersionConstants(versionInfo) {
  const constantsPath = path.join(process.cwd(), 'src', 'lib', 'version-constants.ts');
  
  const content = `// Auto-generated version constants
// This file is generated by scripts/generate-version.js

export const VERSION_INFO = ${JSON.stringify(versionInfo, null, 2)} as const;

export const APP_VERSION = '${versionInfo.version}';
export const BUILD_TIME = '${versionInfo.buildTime}';
export const GIT_HASH = ${versionInfo.gitHash ? `'${versionInfo.gitHash}'` : 'undefined'};
export const ENVIRONMENT = '${versionInfo.environment}';

// Version checking utilities
export function isVersionOutdated(serverVersion: string): boolean {
  return APP_VERSION !== serverVersion;
}

export function getVersionDisplayString(): string {
  const date = new Date(BUILD_TIME).toLocaleDateString();
  const time = new Date(BUILD_TIME).toLocaleTimeString();
  
  if (ENVIRONMENT === 'development') {
    return \`Dev (\${date} \${time})\`;
  }
  
  return \`\${APP_VERSION} (\${date})\`;
}
`;
  
  try {
    fs.writeFileSync(constantsPath, content);
    console.log(`‚úì Version constants written to: ${constantsPath}`);
  } catch (error) {
    console.error('‚ùå Failed to write version constants:', error);
    process.exit(1);
  }
}

function main() {
  console.log('üöÄ Generating version information...');
  
  const versionInfo = generateVersion();
  
  // Write version info to multiple formats
  writeVersionFile(versionInfo);
  updateEnvFile(versionInfo);
  createVersionConstants(versionInfo);
  
  console.log('‚úÖ Version generation complete!');
  console.log(`üìã Version: ${versionInfo.version}`);
  console.log(`üïí Build time: ${versionInfo.buildTime}`);
  console.log(`üåç Environment: ${versionInfo.environment}`);
}

// Handle command line arguments
if (process.argv.includes('--help') || process.argv.includes('-h')) {
  console.log(`
Version Generation Script

Usage:
  node scripts/generate-version.js [options]

Options:
  --help, -h    Show this help message

This script generates version information for the application including:
- Git commit hash (if available)
- Build timestamp
- Environment information

The version info is written to:
- src/lib/version-info.json
- src/lib/version-constants.ts
- .env.local (as NEXT_PUBLIC_* variables)

Examples:
  # Generate version info
  node scripts/generate-version.js

  # In package.json scripts
  "prebuild": "node scripts/generate-version.js"
  `);
  process.exit(0);
}

// Run the script
if (require.main === module) {
  main();
}

module.exports = { generateVersion, writeVersionFile, updateEnvFile, createVersionConstants }; 